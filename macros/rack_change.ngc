o<rack_change> sub
M73 (auto-restore modal settings on return)
; see MCOde Documentation for testing this

; print to console (if available)
;(debug, in change tool_in_spindle=#<tool_in_spindle> current_pocket=#<current_pocket>)
;(debug, selected_tool=#<selected_tool> selected_pocket=#<selected_pocket>)

; Store information otherwise after the M6 this information is gone!
#<tool> = #<selected_tool>
#<pocket> = #<selected_pocket>

; we must execute this macro only in the milltask interpreter
; or preview will break, so test for '#<_task>' which is 1 for 
; the milltask interpreter and 0 in the UI's
O100 if [#<_task> EQ 0]
        (DEBUG, Task is Null)
O100     return [999]
O100 endif

; Alwas the first first go up to maximum Z clearance
G90
G53 G0 Z[#<_ini[AXIS_Z]MAX_LIMIT>-0.1]

; First, get rid of the old tool
; check if the spindle is empty by checking if tool_in_spindle GT 0
O200 if [#<tool_in_spindle> GT 0]
    (DEBUG, Tool No  #<tool_in_spindle> is in the spindle - we need to put it away)
    ; Check if current_pocket is within range, i.e. GT0, LE _ini[ATC_MISC]POCKETS
    O210 if [#<current_pocket> GT 0]
        O220 if [#<current_pocket> LE #<_ini[ATC_MISC]POCKETS>]
            ; Tool within range, triggering put move to rack, assumign that the pocket is empty!
            (DEBUG, Putting tool away at rack into pocket #<current_pocket>)
            ; We are already at safe Z; now rapid to pre psoition for a specific pocket
            G53 G0 X[#<_ini[ATC_FIRST_POCKET]X> + [#<current_pocket> -1] * #<_ini[ATC_TOOL_SLOT_DELTA]X> - #<_ini[ATC_TOOL_SAFE_DISTANCE]X>] Y[#<_ini[ATC_FIRST_POCKET]Y> + [#<current_pocket> -1] * #<_ini[ATC_TOOL_SLOT_DELTA]Y> - #<_ini[ATC_TOOL_SAFE_DISTANCE]Y>] 
            ; Now put the tool down gently 
            o<atc_move_put_tool> call  
            
GET RID OF THAT RELATIVE MOVE SHIT
GET RID OF THAT RELATIVE MOVE SHIT
GET RID OF THAT RELATIVE MOVE SHIT
GET RID OF THAT RELATIVE MOVE SHIT

            Release tool
            Check if Release was ok
            (DEBUG, Tool placed into pocket)
            Move back to rapid safe zone

        O220 endif 
    O210 else
        ; The tool's pocket number is not within the range of the rack and the tool needs to be removed manually
        (DEBUG, Pocket is not within range, moving to manual change)

        ; CODE FOR  DROP OFF AT MANUAL CHANGE 

    O210 endif
0200 elseif [#<tool_in_spindle> EQ 0]
    ; There is nothing to do here but end the if conditional
    (DEBUG, There is no tool in the spindle)
O200 endif

; Second, get new tool
; Check if the new tool number is EQ 0
O300 if [#<selected_tool> EQ 0]
    ; Nothing to here but to move to manual change position and end the program
    (DEBUG, No new tool specified, Finishing)
    G53 G0 X[#<_ini[CHANGE_POSITION]X>] Y[#<_ini[CHANGE_POSITION]Y>]
    G53 G0 Z[#<_ini[CHANGE_POSITION]Z>]
O300 elseif [#<selected_tool> GT 0]
    ; Tool is GT 0 and we need to get it
    (DEBUG, New tool: #<selected_tool> needs to be picked up)
    ; Again, check if within range of the tool rack, otherwise pick at manual change position and measure
        O310 if [#<selected_pocket> GT 0]
        O320 if [#<selected_pocket> LE #<_ini[ATC_MISC]POCKETS>]
            ; Tool within range, triggering get tool from  rack, assumign that the pocket is filled
            (DEBUG, Getting tool #<selected_tool> from rack at  pocket #<selected_pocket>)

            ; CODE FOR PICK UP AT RACK

        O320 endif 
    O310 else
        ; The tool's pocket number is not within the range of the rack and the tool needs to picket up at the manual change position and measured
        (DEBUG, Selected pocket is not within range, moving to manual pick up)

        ; CODE FOR  PICK UP AT MANUAL CHANGE POSITION

    O310 endif

O300 endif

o<rack_change> endsub [1]
M2


; unload previous tool
o300 if [#<_current_pocket> GT 0]
     o<tool_getput_move> call [#<_current_pocket>]  
     M62 P #<_ini[pins]lock> ; set lock pin
     G4  P #<_ini[dwell]lock_time> 
     o<tool_holder_clear_move> call
     G4 P #<_ini[dwell]mystery> ; unsure what this is for
o300 endif


; Assumptions
All tools in a pocket GT 0 AND LE Number Pockets are known and are considered to have entries in the tool table for zero

 gmoccapy can handle macros that call for variables itself - this should allow for a macro to enter a tool into the atc 
 >> basically call an T<toolnumber> M6 and Perform a measurement

TODO
- master macro
- sub macros (check)
- tool measurement macro (should mostly be manual_change)

; Notes
EQ NE GT GE LT LE

#33 = #<_hal[thcad10.target-velocity]>
I did not get an error message and after I closed Linuxcnc, the parameter was saved in linuxcnc.var.
33	11288.476562
==> all lower case


; INPUT OUTPUT
rack tool change needs to operate drawbar and flush
this will require a LUT or other approach to combine the manual button with the motion.digital-out-oo

; net tool-lock   motion.digital-out-00 gladevcp.tool-lock-led  << useless sample
; net tool-flush  motion.digital-out-01 gladevcp.tool-flush-led

rack tool needs to query motion.digital-in-00 and 01 
# --- Jianken Spindle Sensor 11 ---
# Mapping sensor 11 in ATC spindle: signal high = draw bar down (ready to receive tool)
# net spindle_11     <=  hm2_7i76e.0.7i76.0.0.input-11
net spindle_11     motion.digital-in-00 <=  hm2_7i76e.0.7i76.0.0.input-11
# --- Jianken Spindle Sensor 22 ---
# Mapping sensor 22 in ATC spindle: signal high = tool clamped
# net spindle_22     <=  hm2_7i76e.0.7i76.0.0.input-10
net spindle_22   motion.digital-in-01  <=  hm2_7i76e.0.7i76.0.0.input-10
# SIGNAL TABLE
# 11 low 22 low = drawbar closed, no tool
# 11 low 22 high = drawbar closed, tool inserted
# 11 high, 22 low = drawbar open - tool status unknown

==> müsste auch mit m66 auswertbar sein, da immer nur die Änderung eines Punktes von Interesse ist:
Bsp: Tool auswerfen
Release drawbar; wait 2s for 11 change to high THEN move UP THEN check 22 low

    P- - specifies the digital input number from 0 to 3.
    E- - specifies the analog input number from 0 to 3.
    L- - specifies the wait mode type.
        Mode 0: IMMEDIATE - no waiting, returns immediately. The current value of the input is stored in parameter #5399
        Mode 1: RISE - waits for the selected input to perform a rise event.
        Mode 2: FALL - waits for the selected input to perform a fall event.
        Mode 3: HIGH - waits for the selected input to go to the HIGH state.
        Mode 4: LOW - waits for the selected input to go to the LOW state.
    Q- - specifies the timeout in seconds for waiting. If the timeout is exceeded, the wait is interrupt, and the variable #5399 will be holding the value -1. The Q value is ignored if the L-word is zero (IMMEDIATE). A Q value of zero is an error if the L-word is non-zero.
    Mode 0 is the only one permitted for an analog input.
M66 P0 L3 Q5 (wait up to 5 seconds for digital input 0 to turn on)






subs:
atc_tool_holder_clear_move
atc_tool_getput_move



; ALL OF THIS IS ORIGINAL FROM RACKCHANGE

; unload previous tool
o300 if [#<_current_pocket> GT 0]
     o<tool_getput_move> call [#<_current_pocket>]  
     M62 P #<_ini[pins]lock> ; set lock pin
     G4  P #<_ini[dwell]lock_time> 
     o<tool_holder_clear_move> call
     G4 P #<_ini[dwell]mystery> ; unsure what this is for
o300 endif

; go to new tool
o<tool_getput_move> call [#<_selected_pocket>]  
M64 P #<_ini[pins]lock> ; set lock pin
M64 P #<_ini[pins]flush> ; set flush pin
G4  P #<_ini[dwell]new_tool> 
M65 P #<_ini[pins]flush> ; drop flush pin

; the purpose of this move is unclear to me
; micges - please explain!
o400 if [#<_absolute>]
     G91
     G0 Z-6 
     G90
o400 else
     G0 Z-6
o400 endif
M65 P #<_ini[pins]lock> ; drop lock pin
G4  P #<_ini[dwell]post_unlock> 

; NB: this is reordered wrt micges patch:
; tool_holder_clear_move came after load_tool_msg
o<tool_holder_clear_move> call

; succeed by returning a positive value
o<rack_change> endsub [1]
M2